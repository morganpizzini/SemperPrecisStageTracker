@page "/app"
@using SemperPrecisStageTracker.Blazor.Services.IndexDB
@inject ClientConfiguration config
@inject MatchServiceIndexedDb matchServiceIndexDb


@if (config.IsLocal)
{
    <Button Clicked="@Add">aggiungi</Button>
    <Button Clicked="@Get">get</Button>
    <Button Clicked="@Clear">clear</Button>
    @matches.Count

    <ul>
        nei metodi del dettaglio ruolo => quando aggiungo o rimuovo un'entità restituire la lista aggiornata, e non OkResponse
        
        [permessi]
        se elimino un ruolo i permessi associati e gli utenti associati dovrebbero sparire
        se elimino un ruolo tutta la cache degli utenti associati dovrebbe scomparire
        test per aggiornamenti permessi riguardo alla cache, se eseguo un'aggiornamento sui permessi la chiamata di login successiva dovrebbe rispettare i permessi applicati
        
        [memory cache e/o response cache]
        getgroup
        FetchAvailableGroupShooter
        caching sulla base di GetGroupShooterContractByGroupId(string groupId,string matchId = null)
        utenti per authn/authz

        controllare dimensione delle modali
        <li>Spostamento tiratore in altro gruppo</li>

        <li>Gestire parimerito con punti down (fare calcolo inverso, chi ha il tempo maggiore vince, perchè ha avuto minor punti down, ed è stato quindi più preciso)</li>

        [mettere i test]
        controllare tutti i test che aggiungono/rimuovono permessi
        Ogni associazione ha i suoi ruoli per SO CSO SSO
        Ogni associazione impostare quanto vale la penalità
        shooterController campi: data rilascio porto d'armi, nato a, residenza, via, cap, provincia, country, codice fiscale, telefono
        matchcontroller campi: cost, paymentDetails
        permission controller: create e delete user role


        [Blazor]
        se match è unclassified non mostrare la colonna clasificazione, ma solo la divisione nella pagina del dettaglio gruppo e dettaglio stage
        se il match è unclussified devo poter inserire qualsiasi tiratore abbia una shooterassociation adeguata, indipendentemente dalla presenza o meno di attuali classificazioni (come salvare la divisione?)
        Quando vado offline scaricare solo gli stage in cui l'utente è SO o SK, e tutti nel caso in cui sia MD

        [deployment]
        Backup del db

        permessi -> ruolo mettere field per aggiornare name e description

        nel team:
        modalità per iscrizione annuale o solare

        alla cancellazione di un shooterassociationInfo cancellare anche le shooterassociation (inserire anche test)

        controllare ed aggiornare i permessi quando accedo all'applicazione e sono già loggato
        quando aggiorno punti down di una associazione, aggiornare tutti i punti down di shooterstages per i match aperti
        <li>/matches/:id/stats
            <ul>
                <li>controllare assegnazione delle classificazioni, non deve dipendere da shooterassociation ma da groupshooter (metodo GetMatchStats)</li>
            </ul>
        </li>
        <li>creare interfaccia per creare più di un gruppo alla volta</li>

        <li>Controllare top bar in mobile</li>

        <li>Creare un test UI per verificare l'aggiunta di uno shooter in un gruppo</li>

        @*rimuovere i Validator="@ValidationRule.IsNotEmpty"*@
        <li>Nelle associazioni e società inserire regolamento, link e allegato (creare un servizio che carica su blob storage e uno mock che salva in locale)</li>
        <li>All'aggiunta di un punteggio inviare una notifica al tiratore, ogni match ha una flag che permette di disabilitare questo meccanismo, aggiungere anche un pulsante che permette di aggiornare tutti i tiratori in 1 colpo solo</li>
        <li>Form di iscrizione alla gara, con squad</li>
        <li>Gestire le string multiple sugli stage</li>
        <li>Bloccare possibilità di reason in shooterteampayment (??)</li>
        <li>Verificare UI per divisione shooter association</li>
        <li>UI per assegnazione teamHolder</li>
        <li>assegnazione permessi accesso teamHolder</li>
        <li>UI per assegnazione permessi manuale</li>
        <li>Correggere test che danno rosso per permessi, guardare MatchControllerTest per esempi, mancano tutti i test di update/delete</li>

        <li>Nella action UpsertShooterAssociation gestire il doppio salvataggio con una transazione</li>

        <li>Ogni stage ordine randomico dei tiratori, ma stabile sullo stesso stage</li>
        <li>Possibilità di mescolare l'ordine direttamente sulla pagina</li>
        <li>Se entro come SO ho link rapido per stage</li>

        <li>Creare punti di ritrovo per sparare (sicuro/forse/poco probabile) con piccola chat di messaggi</li>

        <li>uniformare customauthservice pescando le informazioni da localstorage https://github.com/Naveen512/Blazor-webassembly-authentication-scratch/tree/main/BlazorWasm.JwtAuthLearning</li>

        <li>upload foto https://www.aspitalia.com/script/1376/Effettuare-Upload-File-Blazor-Azure-Blob-Storage.aspx</li>


        <li>Evidenziare Migliori 3 (oro/argento/bronzo) per ogni stage</li>
        <li>Inserimento link per download immagini</li>
        <li>esportazione in csv</li>
        <li>caricamento immagini per posizione stage</li>
        <li>Opzione lotteria /elimina all'uscita o mantieni</li>
        <li>Caricare configurazione dal server in startup.cs</li>
        <li>virtualization sulle liste e loading dinamico https://docs.microsoft.com/it-it/aspnet/core/blazor/components/virtualization?view=aspnetcore-5.0 </li>

        <li>Dividere la creazione di un match con un wizard, in modo che prima possa settare l'associazione e poi tutto il resto</li>

        Per ogni place segnare i materiali

        <li>Font MV boli</li>

        <li>?? Controllare tastierino numerico su Ios ??</li>
    </ul>
}

@code
{
    private IList<MatchContract> matches = new List<MatchContract>();

    private async Task Add()
    {
        var openResult = await matchServiceIndexDb.OpenIndexedDb();
        await matchServiceIndexDb.AddItems(new List<MatchContract> { new() { MatchId = Guid.NewGuid().ToString(), Name = "Match01" } });
    }

    private async Task Get()
    {
        var openResult = await matchServiceIndexDb.OpenIndexedDb();

        matches = await matchServiceIndexDb.GetAll<MatchContract>();

    }
    private async Task Clear()
    {
        var openResult = await matchServiceIndexDb.OpenIndexedDb();

        await matchServiceIndexDb.DeleteAll<MatchContract>();

    }
}
